{
  "version": 3,
  "sources": ["../lib/printer.js"],
  "sourcesContent": ["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n    : typeof define === 'function' && define.amd ? define('jsonlint-printer', ['exports'], factory)\n      : (global = global || self, factory(global.jsonlintPrinter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  function noop () {}\n\n  function isIdentifierName (value) {\n    return /^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(value)\n  }\n\n  function concatenateTokens (tokens) {\n    let outputString = ''\n    const tokenCount = tokens.length\n    let tokenIndex\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      outputString += tokens[tokenIndex].raw\n    }\n    return outputString\n  }\n\n  function print (tokens, options) {\n    if (!(tokens?.length)) {\n      throw new Error('JSON tokens missing.')\n    }\n    // Whitespace and comments are available only as raw token content.\n    if (!(tokens[0]?.raw)) {\n      throw new Error('JSON tokens lack raw values.')\n    }\n\n    if (!options) {\n      // If no options, not even an empty object is passed, just concatenate\n      // the raw tokens with neither minification, nor pretty-printing.\n      return concatenateTokens(tokens)\n    }\n\n    let indentString = options.indent\n    if (typeof indentString === 'number') {\n      indentString = new Array(indentString + 1).join(' ')\n    }\n    // Setting the indent to an empty string enables pretty-printing too.\n    // It will just insert line breaks without any indentation.\n    const prettyPrint = indentString !== undefined\n    const pruneComments = options.pruneComments\n    const stripObjectKeys = options.stripObjectKeys\n    const enforceDoubleQuotes = options.enforceDoubleQuotes\n    const enforceSingleQuotes = options.enforceSingleQuotes\n    const trimTrailingCommas = options.trimTrailingCommas\n\n    let outputString = ''\n    let foundLineBreak\n    let addedLineBreak\n    let needsLineBreak\n    let addedSpace\n    let needsSpace\n    let indentLevel = 0\n    const scopes = []\n    let scopeType\n    let isValue\n    const tokenCount = tokens.length\n    let tokenIndex\n    let token\n    let tokenType\n    let tokenContent\n\n    function peekAtNextToken () {\n      let nextTokenIndex = tokenIndex\n      let nextToken\n      do {\n        nextToken = tokens[++nextTokenIndex]\n      } while (nextToken && (nextToken.type === 'whitespace' ||\n                             nextToken.type === 'comment'))\n      return nextToken\n    }\n\n    let addIndent\n    if (prettyPrint && indentString) {\n      addIndent = function () {\n        for (let i = 0; i < indentLevel; ++i) {\n          outputString += indentString\n        }\n      }\n    } else {\n      addIndent = noop\n    }\n\n    let addLineBreak\n    let addDelayedSpaceOrLineBreak\n    if (prettyPrint) {\n      addLineBreak = function () {\n        outputString += '\\n'\n      }\n\n      addDelayedSpaceOrLineBreak = function () {\n        // A line break is more important than a space.\n        if (needsLineBreak) {\n          addLineBreak()\n          addIndent()\n        } else if (needsSpace) {\n          outputString += ' '\n        }\n        needsSpace = needsLineBreak = false\n      }\n    } else {\n      addLineBreak = addDelayedSpaceOrLineBreak = noop\n    }\n\n    let addStandaloneComment\n    let tryAddingInlineComment\n    if (pruneComments) {\n      addStandaloneComment = tryAddingInlineComment = noop\n    } else {\n      if (prettyPrint) {\n        addStandaloneComment = function () {\n          // If a comment is not appended to the end of a line, it will start\n          // on a new line with the current indentation.\n          if (!addedLineBreak && tokenIndex > 0) {\n            addLineBreak()\n            addIndent()\n          }\n          outputString += tokenContent\n          foundLineBreak = false\n          addedLineBreak = false\n          // If a comment is not appended to the end of a line, it will take\n          // the whole line and has to end by a line break.\n          needsLineBreak = true\n        }\n\n        tryAddingInlineComment = function () {\n          // This function is called after printing a non-line-break character.\n          foundLineBreak = false\n          addedLineBreak = false\n          addedSpace = false\n\n          // Start with the character after the just processed one.\n          let tryTokenIndex = tokenIndex + 1\n\n          function skipWhitespace () {\n            let token = tokens[tryTokenIndex]\n            if (token && token.type === 'whitespace') {\n              foundLineBreak = token.raw.indexOf('\\n') >= 0\n              token = tokens[++tryTokenIndex]\n            }\n            return token\n          }\n\n          const token = skipWhitespace()\n          // If line break followed the previous token, leave the comment\n          // to be handled by the next usual token processing.\n          if (!foundLineBreak && token && token.type === 'comment') {\n            if (needsLineBreak) {\n              // If the previous non-whitespace token was ended by a line\n              // break, retain it. Print the comment after the line break too.\n              if (!addedLineBreak) {\n                addLineBreak()\n                addIndent()\n              }\n            } else {\n              // If the previous non-whitespace token was not ended by a line\n              // break, ensure that the comment is separated from it.\n              if (!addedSpace) {\n                outputString += ' '\n              }\n            }\n            outputString += token.raw\n            // Set the current token to the just processed comment.\n            tokenIndex = tryTokenIndex++\n            // Check the whitespace after the comment to give a hint\n            // about the next whitespace to the further processing.\n            skipWhitespace()\n            if (foundLineBreak) {\n              needsSpace = false\n              needsLineBreak = true\n            } else {\n              needsSpace = true\n              needsLineBreak = false\n            }\n          }\n        }\n      } else {\n        // If all whitespace is omitted, convert single-line comments\n        // to multi-line ones, which include a comment-closing token.\n        addStandaloneComment = function () {\n          if (tokenContent[1] === '/') {\n            outputString += '/*'\n            outputString += tokenContent.substr(2, tokenContent.length - 2)\n            outputString += ' */'\n          } else {\n            outputString += tokenContent\n          }\n        }\n\n        tryAddingInlineComment = noop\n      }\n    }\n\n    function addLiteral () {\n      addDelayedSpaceOrLineBreak()\n      const tokenValue = token.value\n      if (stripObjectKeys && scopeType === '{' && !isValue &&\n          isIdentifierName(tokenValue)) {\n        outputString += tokenValue\n      } else if (typeof tokenValue === 'string') {\n        if (enforceDoubleQuotes && tokenContent[0] !== '\"') {\n          outputString += JSON.stringify(tokenValue)\n        } else if (enforceSingleQuotes && tokenContent[0] !== '\\'') {\n          outputString += `\\'${tokenValue.replace(/'/g, '\\\\\\'')}\\'`\n        } else {\n          outputString += tokenContent\n        }\n      } else {\n        outputString += tokenContent\n      }\n      tryAddingInlineComment()\n    }\n\n    function openScope () {\n      addDelayedSpaceOrLineBreak()\n      scopes.push(scopeType)\n      scopeType = tokenContent\n      isValue = scopeType === '['\n      outputString += tokenContent\n      tryAddingInlineComment()\n      ++indentLevel\n      needsLineBreak = true\n    }\n\n    function closeScope () {\n      scopeType = scopes.pop()\n      addLineBreak()\n      --indentLevel\n      addIndent()\n      needsSpace = needsLineBreak = false\n      outputString += tokenContent\n      tryAddingInlineComment()\n    }\n\n    function addComma () {\n      if (trimTrailingCommas) {\n        const nextToken = peekAtNextToken()\n        if (nextToken && nextToken.type === 'symbol') {\n          return tryAddingInlineComment()\n        }\n      }\n      addDelayedSpaceOrLineBreak()\n      outputString += ','\n      tryAddingInlineComment()\n      addLineBreak()\n      addIndent()\n      addedLineBreak = true\n      needsLineBreak = false\n      isValue = scopeType === '['\n    }\n\n    function addColon () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ':'\n      needsSpace = true\n      tryAddingInlineComment()\n      isValue = true\n    }\n\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      token = tokens[tokenIndex]\n      tokenType = token.type\n      tokenContent = token.raw\n      switch (tokenType) {\n        case 'literal':\n          addLiteral()\n          break\n        case 'comment':\n          addStandaloneComment()\n          break\n        case 'symbol':\n          switch (tokenContent) {\n            case '{':\n            case '[':\n              openScope()\n              break\n            case '}':\n            case ']':\n              closeScope()\n              break\n            case ',':\n              addComma()\n              break\n            case ':':\n              addColon()\n          }\n          break\n        default: // whitespace\n          foundLineBreak = tokenContent.indexOf('\\n') >= 0\n      }\n    }\n\n    return outputString\n  }\n\n  exports.print = print\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"],
  "mappings": "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",
  "names": ["global", "factory", "exports", "noop", "isIdentifierName", "value", "concatenateTokens", "tokens", "outputString", "tokenCount", "tokenIndex", "print", "options", "indentString", "prettyPrint", "pruneComments", "stripObjectKeys", "enforceDoubleQuotes", "enforceSingleQuotes", "trimTrailingCommas", "foundLineBreak", "addedLineBreak", "needsLineBreak", "addedSpace", "needsSpace", "indentLevel", "scopes", "scopeType", "isValue", "token", "tokenType", "tokenContent", "peekAtNextToken", "nextTokenIndex", "nextToken", "addIndent", "i", "addLineBreak", "addDelayedSpaceOrLineBreak", "addStandaloneComment", "tryAddingInlineComment", "tryTokenIndex", "skipWhitespace", "addLiteral", "tokenValue", "openScope", "closeScope", "addComma", "addColon"]
}
